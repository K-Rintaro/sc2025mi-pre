# RFCを読んで実装してみよう！事前課題

この講義では、インターネット技術の標準的な仕様を策定するRequest for Comments（RFC）を実際に読み、簡単な実装を通して、身近に存在するインターネット技術がどのように成り立っているのかをご体験いただきます。この講義が、皆様の通信プロトコルの興味関心につながる一助になれば幸いです。

Rustを用いて実装に取り組むこととなりますが、プログラミング経験や各種ツールの利用経験があまりない方でも取り組めることを第一に、当日はクイズ感覚で実装ができるよう講義の設計をしておりますのでご安心ください。同時に、経験豊富な方がチャレンジできる発展的な実装もご用意しますのでレベルに応じて取り組んでいただけますと幸いです。

## 事前課題

この講義では、RFCを読んで実装してみるプロトコルとして、SOCKS5プロトコルを取りあげます。SOCKS5を取りあげる理由は様々ありますが、RFCが比較的読み込みやすく、はじめての読解・実装に最適であること、プロキシという形式であるため通信の流れがわかりやすいことなどがあげられます。今回自作するSOCKSによって、実際にトラヒックが転送されている様子を確認することで、みんなで感動を共有できれば幸いです。

事前課題としては、講義で使用する環境のセットアップをしていただき、10月18日当日の講義にスムーズに取り組める状態を事前にご準備いただきます。ご不明点等ございましたらDiscordのチャンネルにてご連絡いただけますと幸いです。

### 1. サーバの接続準備

今回、SOCKSの実装や実行はローカル上では行わず、基本的にクラウド（AWS）上で実行していただきます。これにより、クラウド上で自分で作っていただいたものがローカルと通信しているところを見ることができ、より深い理解につなげたいと考えております。

サーバへはSSHで接続をしていただきます。今回は完全オンライン講義である都合上、IPで接続元を制限することが難しく、セキュリティ上の観点から公開鍵認証で統一させていただきます。そのため、皆様のコンピュータ上でキーペアを生成していただき、公開鍵をDiscordチャンネル（#c_rfcを読んで実装してみよう！）に送信していただけますと幸いです。送信していただいた方から順に接続先情報をお伝えします。鍵生成は各々好きな方法で行ってください。はじめての方は以下が参考になります。

- [Git: 4.3 Gitサーバー - SSH 公開鍵の作成](https://git-scm.com/book/ja/v2/Git%E3%82%B5%E3%83%BC%E3%83%90%E3%83%BC-SSH-%E5%85%AC%E9%96%8B%E9%8D%B5%E3%81%AE%E4%BD%9C%E6%88%90)

### 2. サーバの接続と環境構築

接続が完了すると、次のディレクトリが確認できます。
```
~/
└── socks5/
    ├── Cargo.toml
    ├── Cargo.lock
    ├── src/
    │   └── main.rs
    └── target/
        └── debug/
```

当日はこの`main.rs`を実装いただく形になります。しかしvimエディタなど、コンソール上で実装に取り組むのは大変です。そこで本講義ではVisual Studio CodeのRemote - SSH機能を活用し取り組んでいただきます。

- Visual Studio Code ダウンロードリンク: https://code.visualstudio.com/

Remote - SSH のインストール、使用方法は以下の公式記事が参考になります。

- [Microsoft Learn: 演習 - Visual Studio Code から SSH を使用して接続する](https://learn.microsoft.com/ja-jp/training/modules/develop-on-remote-machine/5-exercise-connect-using-ssh)

お持ちのローカルコンピュータのVisual Studio Codeからディレクトリにアクセスでき、ターミナルが使用できる状態であることをご確認ください。確認できましたら、Rustが実行可能であるかお試しください。既にRustがサーバ上にインストールされているため、次のコマンドが利用できるはずです。

```shell-session
$ cargo run
```

この実行に成功すると、CTFdの最初のフラグが獲得できます。表示される`SECCAMP{}`形式のフラグを事前課題1のFlag欄に入力しご送信ください。

> [!TIP]
> 拡張機能を入れていない標準状態の Visual Studio Code には、Rust 向けの型検査や構文チェック（静的解析）は含まれていません。そのためコンパイルの段階でエラーを確認することとなります。これでは少々不便ですので、必須ではございませんが、拡張機能「rust-analyzer」をインストールいただくことを推奨します。下図の通り、Remote - SSHと同様にExtensionsから導入可能です。
><img alt="Image" src="https://github.com/user-attachments/assets/1609ff3c-ada1-45ce-bdb1-b248da33a5ef"/>

### 3. パケットキャプチャの準備と練習

本講義は単に実装することが目的ではなく、RFCを見ながら、手元で動くプロトコルがどのような決まりによって通信を行っているのかを知ることが目的であります。そのためには、実際に流れるトラヒックを捕捉・確認することが最もわかりやすい方法であるといえます。

> [!NOTE]
> 本講義では、パケットの補足にtcpdumpを用います。ただし今回は、生のtcpdumpは利用しません。
sudo権限を原則利用できないよう制限しており、今回はtcpdumpのみsudoで実行を可能にしつつも、安全でない操作は全て実行できないようにしているラッパースクリプトを作成しましたので、そちらをご利用いただきます。そのため、これまでtcpdumpを利用いただいたことがある場合は、実行方法が少々異なりますが、ご了承いただけますと幸いです。

パケットキャプチャの実行方法は以下の通りです。

```shell-session
$ sudo safe_tcpdump ens5 'tcp port ポート番号'
```

ポート番号として、キャプチャしたいポート番号を指定できます。あるいは以下のように、

```shell-session
$ sudo safe_tcpdump ens5
```

ポートを指定せず実行することも可能です。必要なキャプチャが済んだら、Ctrl + Cで終了できます。キャプチャが終了すると、PCAPという形式のファイルが自動的に生成されます。ファイルの場所については、ホームディレクトリに`tcpdump`ディレクトリが自動で生成され、そのなかに保存されます。（セキュリティ上の都合により、PCAPの保存先指定や任意のオプション指定、ens5以外のインタフェース指定はできません。）

このPCAPファイルをローカルコンピュータにダウンロードし、ローカル環境で分析することで、より細かな、わかりやすい分析を実現することができます。

PCAPファイルのダウンロード方法は下図の通りです。

<img alt="Image" width="70%"  src="https://github.com/user-attachments/assets/c7efcfa8-f359-411c-a6e4-66ec5f3ffa8d" />

Visual Studio Codeで`tcpdump`ディレクトリを開き、該当するPCAPファイルを右クリック、Downloadを選択すると、任意のフォルダにダウンロードすることができます。

ここまで済みましたら、次はダウンロードしてきたPCAPを分析するフェーズに入ります。今回はWiresharkというネットワーク・アナライザ・ソフトウェアを使用します。Wiresharkはパケットの分析に大変便利で、socksを含む様々なプロトコルを認識し、見やすい形でその構造を表示してくれます。

- Wiresharkダウンロードリンク: https://www.wireshark.org/download.html

下図の通り、ダウンロードしたPCAPファイルをWiresharkで開きます。

<img alt="Image" width="70%" src="https://github.com/user-attachments/assets/606bf7b7-5333-4914-8fc5-9dc80b7a2f71" />

Wiresharkが起動すると、キャプチャした様々なパケットの構造が一目で確認できることが分かります。

<img alt="Image" src="https://github.com/user-attachments/assets/736fe316-5a7a-4c92-9a43-5eb6364049ec" />

画面上部の入力欄（表示フィルタ）で特定のポートの通信（例: 8080番, 443番など）や、特定のプロトコルの通信（例: SSH, socksなど）を指定することができます。この講義ではWiresharkの使用方法はあまり重要ではありませんので、`tcp.port == ポート番号`ならびに`socks`などでポート指定、プロトコル指定ができることが確認できれば全く問題ございません。

> [!IMPORTANT]
> Wiresharkの使用に際して、一つだけご設定いただきたい事項がございます。SOCKSプロトコルは通常1080番ポートを使用することとなっており（RFCで規定）、1080番ポート以外を使用して通信した場合、WiresharkはSOCKSに関するパケットであってもSOCKSであると認識せず、単なるTCPパケットとして扱います。これは講義上不都合であります。1台のサーバを4人で共有することとなりますので、全員が1080番を使用して実験することはできないためです。そのため、皆様にそれぞれ割り当てるポート番号のパケットを正しく認識するように、あらかじめ下記の通りご設定いただけますと幸いです。
>
>Wiresharkを開き、[編集(E)] → [設定...(P)] → [Protocols] → [Socks] を選択します。TCP port(s)の欄が、現在`1080`となっているはずですが、これを`1080,8080,8081,8082,8083`にご変更ください。ご不明点等ございましたらDiscordのチャンネルからご連絡いただけますと幸いです。

以上の説明をふまえ、実際に`safe_tcpdump`で自由にパケットをキャプチャし、PCAPファイルをダウンロード、Wiresharkでそのファイルの内容を見てみましょう。一連の作業ができましたら、CTFdの事前課題2のFlag欄に`SECCAMP{COMPLETE}`と入力しご送信ください。

以上が事前課題でございます。

## 任意課題

ここから先は、任意課題となります。当日の講義で確認する内容ですので、必須ではございませんが、現時点での不明点の洗い出しにも有用ですので、余裕のある方は任意でご検討いただけますと幸いです。

当日の読解に使用するRFCはRFC 1928（SOCKS Protocol Version 5）であります。原文は以下からご覧いただけます。

- [IETF Datatracker: RFC 1928 - SOCKS Protocol Version 5](https://datatracker.ietf.org/doc/html/rfc1928)

このRFCを一通り読んでいただき、どのようなフローで具体的に通信が行われるかをご確認ください。比較的分かりやすい英語ではございますが、不明な点等ありましたら、適宜翻訳ツールやChatGPT等の生成AIをご利用いただいて問題ございません。

RFCを読んだうえで、次のようなケースについてお考えください。

メソッドに応じたサブネゴシエーションが完了すると、クライアントは次にRequestを送ることとなります。（4章参照）このとき、クライアントがSOCKS5のCONNECTを用いて、宛先1.1.1.1:80（IPv4）に接続要求を送るとき、Requestメッセージ（TCPペイロード）はどのようなものになると思いますか。

この回答を、カンマ区切りの16進（各1バイト=2桁、例：00）で空白なしで表してください。（例: 05,00,00,00,00,00,00,00,04）答えが分かったら、CTFdの講義課題1のFlag欄に答えをそのまま入力し、ご送信ください。

2つヒントをCTFdに記載しておりますので、参考にしていただけますと幸いです。